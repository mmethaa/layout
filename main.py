import streamlit as st
import pandas as pd
import numpy as np

# Initialize df outside try block to ensure it always exists, even if None
df = None

# --- 1. Load Data ---
# Load the historical data directly from the file system.
# The file 'layoutdata.xlsx - Sheet1.csv' MUST be in the same directory as this script.
try:
    # IMPORTANT: Ensure 'layoutdata.xlsx - Sheet1.csv' is a true CSV file.
    # If it was originally an Excel file, open it in Excel and 'Save As' -> 'CSV (Comma delimited)'.
    # Added encoding='utf-8' for robustness.
    df = pd.read_csv('layoutdata.xlsx - Sheet1.csv', encoding='utf-8')
    
    # Ensure column names are stripped of whitespace for consistency
    df.columns = df.columns.str.strip()
    
    # Calculate Total Units if not already present or needs recalculation based on specific columns
    required_house_cols = ['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°', '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô', '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå']
    existing_house_cols = [col for col in required_house_cols if col in df.columns]

    if existing_house_cols:
        df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'] = df[existing_house_cols].sum(axis=1)
    else:
        # Fallback if house type columns are missing
        st.error("‡∏ö‡∏≤‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ö‡πâ‡∏≤‡∏ô (‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°, ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î, ‡∏Ø‡∏•‡∏Ø) ‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢‡πÑ‡∏õ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•. ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á' ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥.")
        df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'] = 0 # Default to 0, might lead to less accurate predictions

    # Calculate proportion for each house type
    if existing_house_cols:
        df['total_houses_for_prop'] = df[existing_house_cols].sum(axis=1)
        # Handle division by zero for projects with no houses
        for h_type in existing_house_cols: # Loop through existing house types
             df[f'{h_type}_prop'] = df[h_type] / df['total_houses_for_prop'].replace(0, np.nan) 
        df.fillna(0, inplace=True) # Fill NaN proportions with 0
    else:
        st.warning("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ö‡πâ‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•.")

    # Check for essential columns for ratios and dropdowns
    essential_cols = ['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)', '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)', '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)', 
                      '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô‡∏£‡∏ß‡∏°', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢', '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô', '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î']
    for col in essential_cols:
        if col not in df.columns:
            st.warning(f"‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå '{col}' ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•. ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥.")

except FileNotFoundError:
    st.error("Error: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå 'layoutdata.xlsx - Sheet1.csv' ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÑ‡∏î‡πÄ‡∏£‡∏Å‡∏ó‡∏≠‡∏£‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏Å‡∏±‡∏ö‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå.")
    st.stop() # Stop the app if data is not found
except Exception as e: # This will catch the 'str' object has no attribute 'xlsx' error
    st.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå: {e}")
    st.stop()

# --- 2. Pre-calculate average ratios and proportions from historical data ---
# Ratios for area calculations
avg_public_area_ratio = (df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)']).replace([np.inf, -np.inf], np.nan).mean() if df is not None and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤(‡∏ï‡∏£‡∏°)' in df.columns and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)' in df.columns else 0.333
avg_distributable_area_ratio = (df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)']).replace([np.inf, -np.inf], np.nan).mean() if df is not None and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)' in df.columns and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)' in df.columns else 0.667
avg_road_area_ratio = (df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô‡∏£‡∏ß‡∏°'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)']).replace([np.inf, -np.inf], np.nan).mean() if df is not None and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô‡∏£‡∏ß‡∏°' in df.columns and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£(‡∏ï‡∏£‡∏°)' in df.columns else 0.30

# Average area per unit for each type (from user's request)
AREA_TH = 5 * 16  # ‡∏ó‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏Æ‡∏° (‡∏ï‡∏£‡∏°.)
AREA_BA = 12 * 16 # ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î (‡∏ï‡∏£‡∏°.)
AREA_BD = 15 * 18 # ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß (‡∏ï‡∏£‡∏°.)

# Average units per distributable area (overall)
if df is not None and '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á' in df.columns and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)' in df.columns:
    avg_units_per_dist_area = (df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)']).replace([np.inf, -np.inf], np.nan).mean()
else:
    avg_units_per_dist_area = 0.005 # Fallback value if columns missing or data problematic

# House types list for iteration
house_types = ['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°', '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô', '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå']

# Group by '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' and '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô' to get average proportions
# Filter for only existing proportion columns before grouping
existing_prop_cols = [f'{h_type}_prop' for h_type in house_types if f'{h_type}_prop' in df.columns] if df is not None else []
if df is not None and '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' in df.columns and '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô' in df.columns and existing_prop_cols:
    grade_land_shape_proportions = df.groupby(['‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£', '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô'])[existing_prop_cols].mean()
else:
    grade_land_shape_proportions = pd.DataFrame() # Empty if not enough data

# Rules for specific grades (based on initial observation)
grade_rules = {
    'LUXURY': {'‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°': 0, '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î': 0, '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô': 0, '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå': 0}, # Only ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß
    'PREMIUM': {'‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°': 0, '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô': 0, '‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå': 0} # Mostly ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß, some ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î possible
    # Add other grade rules if identified
}

# Average number of alleys per total units
if df is not None and '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢' in df.columns and '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á' in df.columns:
    avg_alley_per_unit = (df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢'] / df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á']).replace([np.inf, -np.inf], np.nan).mean()
else:
    avg_alley_per_unit = 0.05 # Fallback (e.g. 1 alley per 20 units)

if df is not None and '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢' in df.columns and '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)' in df.columns:
    avg_alley_per_dist_area = (df['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢'] / df['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢(‡∏ï‡∏£‡∏°)']).replace([np.inf, -np.inf], np.nan).mean()
else:
    avg_alley_per_dist_area = 0.0001 # Fallback (e.g. 1 alley per 10000 sqm)


# --- 3. Prediction Function ---
def predict_project_layout(
    project_area_sqm: float,
    land_shape: str,
    project_grade: str,
    province: str # Province is currently not used in prediction logic but kept for future expansion
) -> dict:
    """
    Predicts various layout metrics for a new project based on historical data.
    """

    # 1. Predict Area Allocations
    predicted_public_area = project_area_sqm * avg_public_area_ratio
    predicted_distributable_area = project_area_sqm * avg_distributable_area_ratio
    predicted_garden_area = predicted_distributable_area * 0.05
    predicted_road_area = project_area_sqm * avg_road_area_ratio

    # 2. Predict Number of Units by Type and Total Units
    predicted_units = {h_type: 0 for h_type in house_types}
    total_predicted_units = 0

    # Get proportions based on Grade and Land Shape
    proportions_key = (project_grade, land_shape)
    proportions_series = None
    if proportions_key in grade_land_shape_proportions.index:
        proportions_series = grade_land_shape_proportions.loc[proportions_key]
    
    # Calculate base units from distributable area, if avg_units_per_dist_area is valid
    estimated_total_units_from_area = 0
    if not np.isnan(avg_units_per_dist_area) and avg_units_per_dist_area > 0:
        estimated_total_units_from_area = round(predicted_distributable_area * avg_units_per_dist_area)
    
    # Apply grade-specific rules first
    if project_grade in grade_rules:
        for h_type, value in grade_rules[project_grade].items():
            predicted_units[h_type] = value
        
        remaining_house_types = [h for h in house_types if h not in grade_rules[project_grade]]
        
        current_proportions = None
        if proportions_series is not None:
            # Filter proportions series to only include existing house types and those not set to 0 by grade rules
            current_proportions_temp_dict = {h: proportions_series[f'{h}_prop'] for h in remaining_house_types if f'{h}_prop' in proportions_series.index}
            current_proportions_temp = pd.Series(current_proportions_temp_dict)
            
            if current_proportions_temp.sum() > 0:
                current_proportions = current_proportions_temp / current_proportions_temp.sum()
            
        if current_proportions is None or current_proportions.empty: # Fallback to general average if specific or normalized sum is zero or no data
            general_props_temp_dict = {h: df[f'{h}_prop'].mean() for h in remaining_house_types if f'{h}_prop' in df.columns} if df is not None else {}
            general_props_temp = pd.Series(general_props_temp_dict)

            if general_props_temp.sum() > 0:
                current_proportions = general_props_temp / general_props_temp.sum()
            elif remaining_house_types: # Even distribution if all else fails and there are types
                current_proportions = pd.Series([1/len(remaining_house_types)] * len(remaining_house_types), index=remaining_house_types) # Use type names directly
            else:
                current_proportions = pd.Series() # Empty series if no types to distribute

        # Distribute estimated total units among remaining house types
        if current_proportions is not None and not current_proportions.empty:
            for h_type, prop_val in current_proportions.items():
                predicted_units[h_type] = round(estimated_total_units_from_area * prop_val)

        # Refine units based on area consumed
        total_area_consumed_by_known_types = (predicted_units['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] * AREA_TH +
                                              predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] * AREA_BA +
                                              predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] * AREA_BD)
        
        if total_area_consumed_by_known_types > 0 and predicted_distributable_area > 0:
            scale_factor = predicted_distributable_area / total_area_consumed_by_known_types
            for h_type in ['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°', '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß']: # Only types with known area
                predicted_units[h_type] = max(0, round(predicted_units[h_type] * scale_factor))

    else: # No specific grade rules, use average proportions for the given grade/land shape
        # Calculate base units from distributable area
        estimated_total_units_from_area = 0
        if not np.isnan(avg_units_per_dist_area) and avg_units_per_dist_area > 0:
            estimated_total_units_from_area = round(predicted_distributable_area * avg_units_per_dist_area)
            
        current_proportions = None
        if proportions_series is not None:
            current_proportions_temp_dict = {h: proportions_series[f'{h}_prop'] for h in house_types if f'{h}_prop' in proportions_series.index}
            current_proportions_temp = pd.Series(current_proportions_temp_dict)
            if current_proportions_temp.sum() > 0:
                current_proportions = current_proportions_temp / current_proportions_temp.sum()
        
        if current_proportions is None or current_proportions.empty: # Fallback to general average
            general_props_temp_dict = {h: df[f'{h}_prop'].mean() for h in house_types if f'{h}_prop' in df.columns} if df is not None else {}
            general_props_temp = pd.Series(general_props_temp_dict)

            if general_props_temp.sum() > 0:
                current_proportions = general_props_temp / general_props_temp.sum()
            elif house_types: # Even distribution if all else fails
                current_proportions = pd.Series([1/len(house_types)] * len(house_types), index=house_types)
            else:
                current_proportions = pd.Series()

        if current_proportions is not None and not current_proportions.empty:
            for h_type, prop_val in current_proportions.items():
                predicted_units[h_type] = round(estimated_total_units_from_area * prop_val)
        
        # Refine units based on area consumed if possible
        total_area_consumed_by_known_types = (predicted_units['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°'] * AREA_TH +
                                              predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î'] * AREA_BA +
                                              predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß'] * AREA_BD)
        
        if total_area_consumed_by_known_types > 0 and predicted_distributable_area > 0:
            scale_factor = predicted_distributable_area / total_area_consumed_by_known_types
            for h_type in ['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°', '‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î', '‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß']:
                predicted_units[h_type] = max(0, round(predicted_units[h_type] * scale_factor))
                
    total_predicted_units = sum(predicted_units.values())

    # 3. Predict Number of Alleys (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢)
    predicted_alleys = 0
    if total_predicted_units > 0 and not np.isnan(avg_alley_per_unit) and avg_alley_per_unit is not None:
        predicted_alleys = round(total_predicted_units * avg_alley_per_unit)
    elif predicted_distributable_area > 0 and not np.isnan(avg_alley_per_dist_area) and avg_alley_per_dist_area is not None:
        predicted_alleys = round(predicted_distributable_area * avg_alley_per_dist_area)
    
    predicted_alleys = max(1, predicted_alleys) # At least one alley for a project.


    return {
        '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡∏ï‡∏£‡∏°.)': round(project_area_sqm, 2),
        '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏ò‡∏≤ (‡∏ï‡∏£‡∏°.)': round(predicted_public_area, 2),
        '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏î‡∏à‡∏≥‡∏´‡∏ô‡πà‡∏≤‡∏¢ (‡∏ï‡∏£‡∏°.)': round(predicted_distributable_area, 2),
        '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏ô (‡∏ï‡∏£‡∏°.)': round(predicted_garden_area, 2),
        '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô‡∏£‡∏ß‡∏° (‡∏ï‡∏£‡∏°.)': round(predicted_road_area, 2),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏ó‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏Æ‡∏°)': max(0, predicted_units['‡∏ó‡∏≤‡∏ß‡πÇ‡∏Æ‡∏°']),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î)': max(0, predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î']),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß)': max(0, predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß']),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô)': max(0, predicted_units['‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß3‡∏ä‡∏±‡πâ‡∏ô']),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå)': max(0, predicted_units['‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå']),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏£‡∏ß‡∏°)': max(0, total_predicted_units),
        '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢': max(1, predicted_alleys)
    }

# --- 4. Streamlit UI ---
st.set_page_config(
    page_title="Layout Project Predictor",
    layout="centered",
    initial_sidebar_state="expanded"
)

st.title("üè° ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏±‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà")
st.markdown("‡πÇ‡∏õ‡∏£‡∏î‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏±‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ö‡πâ‡∏≤‡∏ô. (‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• `layoutdata.xlsx - Sheet1.csv` ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÑ‡∏î‡πÄ‡∏£‡∏Å‡∏ó‡∏≠‡∏£‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏ô‡∏µ‡πâ)")

# Get unique values for dropdowns from loaded data
# Ensure columns exist before accessing unique values, provide fallback if not
unique_land_shapes = df['‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô'].unique().tolist() if df is not None and '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô' in df.columns else []
unique_grades = df['‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£'].unique().tolist() if df is not None and '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' in df.columns else []
unique_provinces = df['‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î'].unique().tolist() if df is not None and '‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î' in df.columns else []

st.header("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà")
col1, col2 = st.columns(2)

with col1:
    project_area = st.number_input(
        "‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡∏ï‡∏£‡∏°.)",
        min_value=1000.0,
        max_value=1000000.0,
        value=50000.0,
        step=1000.0,
        help="‡∏õ‡πâ‡∏≠‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£"
    )

with col2:
    if unique_land_shapes:
        land_shape = st.selectbox(
            "‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô",
            options=unique_land_shapes,
            help="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà"
        )
    else:
        st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô' ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ô‡∏µ‡πâ.")
        land_shape = "" # Default to empty if no data

col3, col4 = st.columns(2)
with col3:
    if unique_grades:
        project_grade = st.selectbox(
            "‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£",
            options=unique_grades,
            help="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏Å‡∏£‡∏î‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£ (‡πÄ‡∏ä‡πà‡∏ô PREMIUM, LUXURY, BELLA)"
        )
    else:
        st.error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ô‡∏µ‡πâ.")
        project_grade = "" # Default to empty if no data

with col4:
    if unique_provinces:
        province = st.selectbox(
            "‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î",
            options=unique_provinces,
            help="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏≠‡∏¢‡∏π‡πà (‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á)"
        )
    else:
        st.warning("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• '‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏±‡∏î' ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•. ‡∏ä‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì.")
        province = "N/A" # Default to N/A if no data

if st.button("‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏±‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£"):
    # Basic validation for essential inputs
    if project_area <= 0:
        st.error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡πâ‡∏≠‡∏ô '‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' ‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0.")
    elif not land_shape: # Check if land_shape is empty string due to missing column
        st.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• '‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô' ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì.")
    elif not project_grade: # Check if project_grade is empty string due to missing column
        st.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• '‡πÄ‡∏Å‡∏£‡∏î‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£' ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å. ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì.")
    else:
        # Perform prediction
        with st.spinner("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì..."):
            predicted_results = predict_project_layout(
                project_area_sqm=project_area,
                land_shape=land_shape,
                project_grade=project_grade,
                province=province
            )
        
        st.success("‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ú‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!")
        st.header("‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢")
        
        # Display results in an organized way (e.g., using st.metric or a DataFrame)
        results_df = pd.DataFrame(predicted_results.items(), columns=["‡∏ï‡∏±‡∏ß‡∏ä‡∏µ‡πâ‡∏ß‡∏±‡∏î", "‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢"])
        st.dataframe(results_df, hide_index=True)

        st.markdown("""
        ---
        **‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:**
        * ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡πÅ‡∏•‡∏∞‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï.
        * ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß 3 ‡∏ä‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏•‡∏±‡∏á ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡πÄ‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏Æ‡∏° ‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏ù‡∏î ‡πÅ‡∏•‡∏∞‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß.
        * '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á (‡∏£‡∏ß‡∏°)' ‡∏Ñ‡∏∑‡∏≠‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏ö‡πâ‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó.
        * '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ã‡∏≠‡∏¢' ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà 1.
        """)
